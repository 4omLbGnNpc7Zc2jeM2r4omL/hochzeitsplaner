window.TischplanungRenderer = {
    core: null,
    renderCache: new Map(),
    saveTimeout: null,

    renderSeatingChart(coreInstance) {
        this.core = coreInstance;
        console.log('üé® Beginne Rendering der Tischplanung');
        console.log('üìä Daten:', {
            tables: this.core.tables.length,
            guests: this.core.guests.length,
            seatingChart: this.core.seatingChart
        });
        
        // Rendering in Batches f√ºr bessere Performance
        requestAnimationFrame(() => {
            this.clearOldElements();
            this.renderTables();
            
            requestAnimationFrame(() => {
                this.renderGuestList();
                this.updateStatistics();
                console.log('‚úÖ Tischplanung-Rendering abgeschlossen');
            });
        });
    },

    clearOldElements() {
        // Nur notwendige Elemente entfernen
        const existingTables = this.core.seatingChart.querySelectorAll('.table-element');
        existingTables.forEach(el => {
            const tableId = el.dataset.tableId;
            if (!this.core.tables.find(t => t.id == tableId)) {
                el.remove();
                this.renderCache.delete(`table-${tableId}`);
            }
        });
    },

    renderTables() {
        console.log('üçΩÔ∏è Rendering Tische:', this.core.tables.length);
        
        if (!this.core.seatingChart) {
            console.error('‚ùå seatingChart Container nicht gefunden!');
            return;
        }
        
        this.core.tables.forEach((table, index) => {
            console.log(`üçΩÔ∏è Rendering Tisch ${index + 1}:`, table);
            
            const cacheKey = `table-${table.id}`;
            const cachedElement = this.renderCache.get(cacheKey);
            
            if (cachedElement && this.isTableUnchanged(table, cachedElement)) {
                this.updateTablePosition(cachedElement.element, table);
                return;
            }

            let tableElement = this.core.seatingChart.querySelector(`[data-table-id="${table.id}"]`);
            
            if (tableElement) {
                this.updateTableElement(tableElement, table);
            } else {
                tableElement = this.createTableElement(table);
                this.core.seatingChart.appendChild(tableElement);
                console.log(`‚úÖ Tisch ${table.name} erstellt und hinzugef√ºgt`);
            }

            this.renderCache.set(cacheKey, {
                element: tableElement,
                lastUpdate: Date.now(),
                tableData: { ...table }
            });
        });
        
        console.log(`‚úÖ ${this.core.tables.length} Tische gerendert`);
    },

    createTableElement(table, occupancy = 0) {
        console.log('Erstelle Tisch-Element f√ºr:', table.name);
        
        // Berechne zugeordnete G√§ste f√ºr diesen Tisch
        const assignedGuests = this.getAssignedGuestsForTable(table.id);
        const guestCount = assignedGuests.length;
        
        // Dynamische Gr√∂√üenberechnung basierend auf G√§steanzahl und Namen
        const dynamicSize = this.calculateTableSize(assignedGuests, table);
        
        // Tisch-Container erstellen
        const tableElement = document.createElement('div');
        tableElement.className = 'table-element';
        tableElement.style.width = `${dynamicSize.width}px`;
        tableElement.style.height = `${dynamicSize.height}px`;
        const capacity = table.capacity || table.max_personen || 8;
        const shape = table.shape || table.form || 'round';
        const name = table.name || `Tisch ${table.id}`;
        
        const tableElement = document.createElement('div');
        tableElement.className = 'table-element';
        tableElement.dataset.tableId = table.id;
        tableElement.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: ${y}px;
            width: ${width}px;
            height: ${height}px;
            border: 2px solid #007bff;
            border-radius: ${shape === 'round' ? '50%' : '8px'};
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s ease;
            z-index: 10;
        `;

        // Event Listeners
        this.addTableEventListeners(tableElement, table);

        // Content
        this.updateTableContent(tableElement, table);

        return tableElement;
    },

    updateTableElement(element, table) {
        this.updateTablePosition(element, table);
        this.updateTableContent(element, table);
        this.updateTableStyle(element, table);
    },

    updateTablePosition(element, table) {
        const x = table.x || table.x_position || 100;
        const y = table.y || table.y_position || 100;
        element.style.left = `${x}px`;
        element.style.top = `${y}px`;
    },

    updateTableContent(element, table) {
        const capacity = table.capacity || table.max_personen || 8;
        const name = table.name || `Tisch ${table.id}`;
        const assignedGuests = this.core.guests.filter(g => g.table_id === table.id);
        
        element.innerHTML = `
            <div class="table-name" style="font-weight: bold; font-size: 0.9rem; margin-bottom: 4px; color: #333;">
                ${name}
            </div>
            <div class="table-capacity" style="font-size: 0.8rem; color: #666;">
                ${assignedGuests.length}/${capacity}
            </div>
            <div class="table-guests" style="font-size: 0.7rem; color: #888; text-align: center; max-height: 60px; overflow: hidden;">
                ${assignedGuests.slice(0, 3).map(g => {
                    const guestName = g.name || `${g.vorname || ''} ${g.nachname || ''}`.trim();
                    return guestName;
                }).join('<br>')}
                ${assignedGuests.length > 3 ? '<br>...' : ''}
            </div>
        `;
    },

    updateTableStyle(element, table) {
        const capacity = table.capacity || table.max_personen || 8;
        const assignedGuests = this.core.guests.filter(g => g.table_id === table.id);
        const isOverCapacity = assignedGuests.length > capacity;
        const isEmpty = assignedGuests.length === 0;

        let borderColor = table.farbe || '#007bff';
        let backgroundColor = 'linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%)';

        if (isOverCapacity) {
            borderColor = '#dc3545';
            backgroundColor = 'linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%)';
        } else if (isEmpty) {
            borderColor = '#6c757d';
            backgroundColor = 'linear-gradient(135deg, #e9ecef 0%, #f8f9fa 100%)';
        }

        element.style.borderColor = borderColor;
        element.style.background = backgroundColor;
    },

    addTableEventListeners(element, table) {
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let startX = 0;
        let startY = 0;

        // Einfacher Klick - Tisch ausw√§hlen
        element.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!isDragging) {
                this.selectTable(table);
            }
        });

        // Doppelklick - Tisch bearbeiten
        element.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            this.editTable(table);
        });

        // Drag-Funktionalit√§t f√ºr freie Positionierung
        element.addEventListener('mousedown', (e) => {
            if (e.button === 0) { // Nur linke Maustaste
                isDragging = false;
                dragStartX = e.clientX;
                dragStartY = e.clientY;
                startX = table.x || table.x_position || 100;
                startY = table.y || table.y_position || 100;
                
                element.style.cursor = 'grabbing';
                element.style.zIndex = '1000';
                
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (dragStartX !== 0) {
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;
                
                // Mindestbewegung f√ºr Drag-Erkennung
                if (!isDragging && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
                    isDragging = true;
                    element.classList.add('moving');
                }
                
                if (isDragging) {
                    const newX = startX + deltaX;
                    const newY = startY + deltaY;
                    
                    // Positionsgrenzen pr√ºfen
                    const seatingChart = this.core.seatingChart;
                    const minX = 60; // Mindestabstand zum Rand
                    const minY = 60;
                    const maxX = seatingChart.offsetWidth - 180; // Tischbreite ber√ºcksichtigen
                    const maxY = seatingChart.offsetHeight - 180;
                    
                    const clampedX = Math.max(minX, Math.min(maxX, newX));
                    const clampedY = Math.max(minY, Math.min(maxY, newY));
                    
                    element.style.left = `${clampedX}px`;
                    element.style.top = `${clampedY}px`;
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (dragStartX !== 0) {
                if (isDragging) {
                    // Position speichern
                    const newX = parseInt(element.style.left);
                    const newY = parseInt(element.style.top);
                    
                    this.saveTablePosition(table, newX, newY);
                }
                
                // Reset
                isDragging = false;
                dragStartX = 0;
                dragStartY = 0;
                element.style.cursor = 'pointer';
                element.style.zIndex = '10';
                element.classList.remove('moving');
            }
        });

        // Drop-Funktionalit√§t f√ºr G√§ste
        element.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!isDragging) {
                element.style.borderColor = '#28a745';
                element.style.transform = 'scale(1.05)';
            }
        });

        element.addEventListener('dragleave', (e) => {
            e.stopPropagation();
            if (!isDragging) {
                this.updateTableStyle(element, table);
                element.style.transform = '';
            }
        });

        element.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (!isDragging) {
                this.handleTableDrop(table);
                element.style.transform = '';
            }
        });
    },

    renderGuestList() {
        const guestListContainer = document.getElementById('guestList');
        const guestCountElement = document.getElementById('guestCount');
        
        if (!guestListContainer) {
            console.warn('‚ö†Ô∏è guestList Container nicht gefunden');
            return;
        }

        // Update guest count - zeige Summe der anzahl_essen
        if (guestCountElement) {
            const totalEssenGuests = this.core.guests.reduce((sum, guest) => {
                const anzahlEssen = guest.anzahl_essen || guest.Anzahl_Essen || 0;
                return sum + anzahlEssen;
            }, 0);
            guestCountElement.textContent = totalEssenGuests;
        }

        // Render all guests (assigned and unassigned)
        guestListContainer.innerHTML = this.core.guests.map(guest => {
            const isAssigned = guest.table_id;
            const table = isAssigned ? this.core.tables.find(t => t.id === guest.table_id) : null;
            
            return `
                <div class="list-group-item guest-list-item ${isAssigned ? 'assigned' : ''}" 
                     draggable="true" data-guest-id="${guest.id}"
                     style="cursor: grab; border-left: 4px solid ${isAssigned ? '#28a745' : '#6c757d'};">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <div style="font-weight: 500;">${guest.vorname || guest.name} ${guest.nachname || ''}</div>
                            <small class="text-muted">${guest.email || ''}</small>
                            ${isAssigned ? `<br><small class="text-success">Tisch: ${table ? table.name : 'Unbekannt'}</small>` : ''}
                        </div>
                        <div>
                            ${(guest.anzahl_essen || guest.Anzahl_Essen) ? `<span class="badge bg-secondary">${guest.anzahl_essen || guest.Anzahl_Essen}</span>` : ''}
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        // Drag Events f√ºr G√§ste
        guestListContainer.querySelectorAll('.guest-list-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                const guestId = parseInt(item.dataset.guestId);
                this.core.draggedGuest = this.core.guests.find(g => g.id === guestId);
                e.dataTransfer.effectAllowed = 'move';
                item.classList.add('dragging');
            });
            
            item.addEventListener('dragend', (e) => {
                item.classList.remove('dragging');
            });
        });
    },

    updateStatistics() {
        const statsContainer = document.getElementById('tischplanungStats');
        console.log('üìä Update Statistics:', {
            statsContainer: !!statsContainer,
            tables: this.core.tables.length,
            guests: this.core.guests.length
        });
        
        if (!statsContainer) return;

        // Berechne Statistiken basierend auf anzahl_essen
        const totalEssenGuests = this.core.guests.reduce((sum, guest) => {
            const anzahlEssen = guest.anzahl_essen || guest.Anzahl_Essen || 0;
            return sum + anzahlEssen;
        }, 0);
        
        const assignedEssenGuests = this.core.guests.filter(g => g.table_id).reduce((sum, guest) => {
            const anzahlEssen = guest.anzahl_essen || guest.Anzahl_Essen || 0;
            return sum + anzahlEssen;
        }, 0);
        
        const totalCapacity = this.core.tables.reduce((sum, table) => sum + (table.capacity || 8), 0);

        statsContainer.innerHTML = `
            <div class="row text-center">
                <div class="col-md-3">
                    <h5>${this.core.tables.length}</h5>
                    <small>Tische</small>
                </div>
                <div class="col-md-3">
                    <h5>${assignedEssenGuests}/${totalEssenGuests}</h5>
                    <small>Zugewiesene Essensg√§ste</small>
                </div>
                <div class="col-md-3">
                    <h5>${totalCapacity}</h5>
                    <small>Gesamtkapazit√§t</small>
                </div>
                <div class="col-md-3">
                    <h5 class="${assignedEssenGuests === totalEssenGuests ? 'text-success' : 'text-warning'}">
                        ${totalEssenGuests > 0 ? Math.round((assignedEssenGuests / totalEssenGuests) * 100) : 0}%
                    </h5>
                    <small>Vollst√§ndig</small>
                </div>
            </div>
        `;
    },

    selectTable(table) {
        // Remove previous selection
        this.core.seatingChart.querySelectorAll('.table-element').forEach(el => {
            el.style.transform = '';
            el.style.zIndex = '10';
        });

        // Select new table
        const tableElement = this.core.seatingChart.querySelector(`[data-table-id="${table.id}"]`);
        if (tableElement) {
            tableElement.style.transform = 'scale(1.1)';
            tableElement.style.zIndex = '20';
        }

        this.core.selectedTable = table;
        this.showTableDetails(table);
    },

    showTableDetails(table) {
        const detailsContainer = document.getElementById('tableDetails');
        if (!detailsContainer) return;

        const assignedGuests = this.core.guests.filter(g => g.table_id === table.id);

        detailsContainer.innerHTML = `
            <h6>Tisch: ${table.name}</h6>
            <p>Kapazit√§t: ${table.capacity} Personen</p>
            <p>Belegt: ${assignedGuests.length} Personen</p>
            <div class="assigned-guests">
                <strong>G√§ste:</strong>
                <ul class="list-unstyled mt-2">
                    ${assignedGuests.map(g => `<li>${g.name}</li>`).join('')}
                </ul>
            </div>
            <button class="btn btn-sm btn-outline-danger mt-2" onclick="clearTable(${table.id})">
                Tisch leeren
            </button>
        `;
    },

    handleTableDrop(table) {
        if (this.core.draggedGuest && window.TischplanungEventHandlers) {
            window.TischplanungEventHandlers.assignGuestToTable(this.core.draggedGuest, table);
        }
    },

    editTable(table) {
        console.log('‚úèÔ∏è Bearbeite Tisch:', table.name);
        
        // Entferne vorheriges Modal falls vorhanden
        const existingModal = document.getElementById('editTableModal');
        if (existingModal) {
            existingModal.remove();
        }

        const capacity = table.capacity || table.max_personen || 8;
        const name = table.name || `Tisch ${table.id}`;
        const farbe = table.farbe || '#007bff';
        const form = table.shape || table.form || 'round';

        const modalHtml = `
            <div class="modal fade" id="editTableModal" tabindex="-1">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-pencil me-2"></i>Tisch bearbeiten
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <form id="editTableForm">
                                <div class="mb-3">
                                    <label class="form-label">Tischname</label>
                                    <input type="text" class="form-control" id="editTableName" value="${name}" required>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Kapazit√§t</label>
                                    <input type="number" class="form-control" id="editTableCapacity" value="${capacity}" min="2" max="20" required>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Form</label>
                                    <select class="form-select" id="editTableShape">
                                        <option value="round" ${form === 'round' ? 'selected' : ''}>Rund</option>
                                        <option value="square" ${form === 'square' ? 'selected' : ''}>Quadratisch</option>
                                        <option value="rectangle" ${form === 'rectangle' ? 'selected' : ''}>Rechteckig</option>
                                    </select>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Farbe</label>
                                    <div class="d-flex align-items-center">
                                        <input type="color" class="form-control form-control-color me-3" id="editTableColor" value="${farbe}" style="width: 60px;">
                                        <div class="btn-group btn-group-sm" role="group">
                                            <button type="button" class="btn btn-outline-primary" onclick="setTableColor('#007bff')">Blau</button>
                                            <button type="button" class="btn btn-outline-success" onclick="setTableColor('#28a745')">Gr√ºn</button>
                                            <button type="button" class="btn btn-outline-warning" onclick="setTableColor('#ffc107')">Gelb</button>
                                            <button type="button" class="btn btn-outline-danger" onclick="setTableColor('#dc3545')">Rot</button>
                                            <button type="button" class="btn btn-outline-info" onclick="setTableColor('#17a2b8')">Cyan</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="mb-3">
                                    <label class="form-label">Position</label>
                                    <div class="row">
                                        <div class="col-6">
                                            <label class="form-label form-label-sm">X</label>
                                            <input type="number" class="form-control form-control-sm" id="editTableX" value="${table.x || table.x_position || 100}">
                                        </div>
                                        <div class="col-6">
                                            <label class="form-label form-label-sm">Y</label>
                                            <input type="number" class="form-control form-control-sm" id="editTableY" value="${table.y || table.y_position || 100}">
                                        </div>
                                    </div>
                                </div>
                            </form>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-danger" onclick="deleteTableConfirm(${table.id})">
                                <i class="bi bi-trash me-1"></i>L√∂schen
                            </button>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Abbrechen</button>
                            <button type="button" class="btn btn-primary" onclick="saveTableEdit(${table.id})">
                                <i class="bi bi-save me-1"></i>Speichern
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHtml);

        // Globale Hilfsfunktionen
        window.setTableColor = function(color) {
            document.getElementById('editTableColor').value = color;
        };

        window.saveTableEdit = async function(tableId) {
            const name = document.getElementById('editTableName').value.trim();
            const capacity = parseInt(document.getElementById('editTableCapacity').value);
            const shape = document.getElementById('editTableShape').value;
            const farbe = document.getElementById('editTableColor').value;
            const x = parseInt(document.getElementById('editTableX').value);
            const y = parseInt(document.getElementById('editTableY').value);

            if (!name) {
                alert('Bitte einen Tischnamen eingeben');
                return;
            }

            // Loading-Indikator anzeigen
            const saveButton = document.querySelector(`[onclick="saveTableEdit(${tableId})"]`);
            const originalText = saveButton.innerHTML;
            saveButton.innerHTML = '<i class="spinner-border spinner-border-sm me-1"></i>Speichere...';
            saveButton.disabled = true;

            const updateData = {
                name: name,
                capacity: capacity,
                shape: shape,
                farbe: farbe,
                x: x,
                y: y
            };

            try {
                const result = await window.TischplanungAPI.updateTable(tableId, updateData);
                if (result.message || result.success !== false) {
                    // Modal sofort schlie√üen
                    document.getElementById('editTableModal').remove();
                    
                    // Tisch-Element sofort aktualisieren (optimistische UI)
                    const tableElement = document.querySelector(`[data-table-id="${tableId}"]`);
                    if (tableElement) {
                        // Position aktualisieren
                        tableElement.style.left = `${x}px`;
                        tableElement.style.top = `${y}px`;
                        
                        // Farbe aktualisieren
                        tableElement.style.borderColor = farbe;
                        
                        // Shape aktualisieren
                        tableElement.style.borderRadius = shape === 'round' ? '50%' : '8px';
                        
                        // Inhalt aktualisieren
                        const nameElement = tableElement.querySelector('.table-name');
                        if (nameElement) nameElement.textContent = name;
                        
                        const capacityElement = tableElement.querySelector('.table-capacity');
                        if (capacityElement) {
                            const currentGuests = capacityElement.textContent.split('/')[0];
                            capacityElement.textContent = `${currentGuests}/${capacity}`;
                        }
                    }
                    
                    // Daten im Hintergrund synchronisieren (non-blocking)
                    setTimeout(async () => {
                        try {
                            await window.tischplanung.loadTables();
                            window.tischplanung.render();
                        } catch (error) {
                            console.warn('Fehler beim Neuladen der Daten:', error);
                        }
                    }, 100);
                    
                    if (window.showSuccess) {
                        window.showSuccess('Tisch erfolgreich aktualisiert');
                    } else {
                        alert('Tisch erfolgreich aktualisiert');
                    }
                } else {
                    throw new Error(result.error || 'Unbekannter Fehler');
                }
            } catch (error) {
                // Button zur√ºcksetzen bei Fehler
                saveButton.innerHTML = originalText;
                saveButton.disabled = false;
                
                console.error('Fehler beim Aktualisieren des Tisches:', error);
                if (window.showError) {
                    window.showError('Fehler beim Aktualisieren: ' + error.message);
                } else {
                    alert('Fehler beim Aktualisieren: ' + error.message);
                }
            }
        };

        window.deleteTableConfirm = async function(tableId) {
            const confirmed = confirm('M√∂chten Sie diesen Tisch wirklich l√∂schen? Alle G√§ste-Zuordnungen gehen verloren.');
            if (!confirmed) return;

            // Loading-Indikator anzeigen
            const deleteButton = document.querySelector(`[onclick="deleteTableConfirm(${tableId})"]`);
            const originalText = deleteButton.innerHTML;
            deleteButton.innerHTML = '<i class="spinner-border spinner-border-sm me-1"></i>L√∂sche...';
            deleteButton.disabled = true;

            try {
                const result = await window.TischplanungAPI.deleteTable(tableId);
                if (result.message || result.success !== false) {
                    // Modal sofort schlie√üen
                    document.getElementById('editTableModal').remove();
                    
                    // Tisch sofort aus der Anzeige entfernen (optimistische UI)
                    const tableElement = document.querySelector(`[data-table-id="${tableId}"]`);
                    if (tableElement) {
                        tableElement.style.transition = 'all 0.3s ease';
                        tableElement.style.opacity = '0';
                        tableElement.style.transform = 'scale(0.8)';
                        setTimeout(() => tableElement.remove(), 300);
                    }
                    
                    // Cache bereinigen
                    window.TischplanungRenderer.removeTableFromCache(tableId);
                    
                    // Daten im Hintergrund aktualisieren (non-blocking)
                    setTimeout(async () => {
                        try {
                            await window.tischplanung.loadTables();
                            window.tischplanung.render();
                        } catch (error) {
                            console.warn('Fehler beim Neuladen der Daten:', error);
                        }
                    }, 100);
                    
                    if (window.showSuccess) {
                        window.showSuccess('Tisch erfolgreich gel√∂scht');
                    } else {
                        alert('Tisch erfolgreich gel√∂scht');
                    }
                } else {
                    throw new Error(result.error || 'Unbekannter Fehler');
                }
            } catch (error) {
                // Button zur√ºcksetzen bei Fehler
                deleteButton.innerHTML = originalText;
                deleteButton.disabled = false;
                
                console.error('Fehler beim L√∂schen des Tisches:', error);
                if (window.showError) {
                    window.showError('Fehler beim L√∂schen: ' + error.message);
                } else {
                    alert('Fehler beim L√∂schen: ' + error.message);
                }
            }
        };

        // Modal anzeigen
        const modal = new bootstrap.Modal(document.getElementById('editTableModal'));
        modal.show();

        // Modal nach dem Schlie√üen aus DOM entfernen
        document.getElementById('editTableModal').addEventListener('hidden.bs.modal', function() {
            this.remove();
        });
    },

    saveTablePosition(table, newX, newY) {
        console.log(`üíæ Speichere Position f√ºr Tisch ${table.name}: (${newX}, ${newY})`);
        
        const updateData = {
            x_position: newX,
            y_position: newY
        };

        // Lokale Daten sofort aktualisieren f√ºr bessere UX
        table.x = newX;
        table.y = newY;
        if (table.x_position !== undefined) table.x_position = newX;
        if (table.y_position !== undefined) table.y_position = newY;

        // Debouncing f√ºr API-Aufrufe - verhindert zu viele gleichzeitige Requests
        if (this.saveTimeout) {
            clearTimeout(this.saveTimeout);
        }
        
        this.saveTimeout = setTimeout(async () => {
            try {
                if (window.TischplanungAPI) {
                    const result = await window.TischplanungAPI.updateTable(table.id, updateData);
                    if (!result.message && result.success === false) {
                        console.error('Fehler beim Speichern der Position:', result.error);
                        if (window.showError) {
                            window.showError('Position konnte nicht gespeichert werden: ' + result.error);
                        }
                    } else {
                        console.log('‚úÖ Position erfolgreich gespeichert');
                    }
                } else {
                    console.warn('‚ö†Ô∏è TischplanungAPI nicht verf√ºgbar');
                }
            } catch (error) {
                console.error('Fehler beim Speichern der Tisch-Position:', error);
                if (window.showError) {
                    window.showError('Fehler beim Speichern: ' + error.message);
                }
            }
        }, 500); // 500ms Debounce-Zeit
    },

    isTableUnchanged(table, cachedData) {
        if (!cachedData) return false;
        
        const cached = cachedData.tableData;
        return (
            cached.name === table.name &&
            cached.x_position === table.x_position &&
            cached.y_position === table.y_position &&
            cached.max_personen === table.max_personen &&
            cached.farbe === table.farbe
        );
    },

    removeTableFromCache(tableId) {
        this.renderCache.delete(`table-${tableId}`);
    },

    updateTableInCache(tableId, tableData) {
        const cacheKey = `table-${tableId}`;
        const cached = this.renderCache.get(cacheKey);
        if (cached) {
            cached.tableData = { ...tableData };
            cached.lastUpdate = Date.now();
        }
    }
};
