#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
SSL-Launcher f√ºr Hochzeitsplaner Web-Anwendung
Mit echten SSL-Zertifikaten von Ionos
Dual-Domain Support: hochzeitsplaner.de (lokal) + pascalundk√§the-heiraten.de (Internet)
"""
import json
import os
import sys
import socket
import subprocess
import webbrowser
import threading
import time
import shutil
from pathlib import Path

class SimpleConfig:
    """Einfache Konfigurationsverwaltung"""
    
    def __init__(self):
        self.config_file = "launcher_config.json"
        self.config = self.load_config()
        
    def load_config(self):
        """L√§dt Konfiguration aus JSON-Datei"""
        default_config = {
            "data_directory": "",
            "port": 8080,
            "host": "0.0.0.0",  # Erlaube Zugriff von allen Netzwerk-Interfaces
            "ssl_enabled": True,  # SSL standardm√§√üig aktiviert
            "auto_open_browser": True,
            "first_run": True
        }
        
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                    # Merge mit Default-Werten
                    for key, value in default_config.items():
                        if key not in config:
                            config[key] = value
                    return config
            except Exception as e:
                print(f"‚ö†Ô∏è  Fehler beim Laden der Konfiguration: {e}")
        
        return default_config
    
    def save_config(self):
        """Speichert Konfiguration in JSON-Datei"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"‚ö†Ô∏è  Fehler beim Speichern der Konfiguration: {e}")
    
    def setup_data_directory(self):
        """Richtet Datenverzeichnis ein"""
        # Aktueller Pfad - korrekte Erkennung f√ºr PyInstaller auf Windows
        if getattr(sys, 'frozen', False):
            # Wenn als .exe ausgef√ºhrt (PyInstaller)
            application_path = os.path.dirname(sys.executable)
        else:
            # Normal als Python-Script
            application_path = os.path.dirname(os.path.abspath(__file__))
        
        # Bei ersten Start: Datenverzeichnis konfigurieren
        if self.config.get('first_run', True) or not self.config.get('data_directory'):
            print("üè† ERSTKONFIGURATION - Datenverzeichnis festlegen")
            print("="*60)
            print("Der Hochzeitsplaner ben√∂tigt ein Verzeichnis f√ºr Ihre Daten.")
            print("Empfehlung: W√§hlen Sie einen Ordner in Ihren Dokumenten.")
            print()
            
            while True:
                data_input = input("üìÅ Pfad zum Datenverzeichnis (oder Enter f√ºr Standard): ").strip()
                
                if not data_input:
                    # Standard: data-Verzeichnis neben der Anwendung
                    data_path = Path(application_path) / "data"
                    print(f"‚úÖ Verwende Standard-Verzeichnis: {data_path}")
                    break
                else:
                    data_path = Path(data_input)
                    
                    # Pr√ºfe ob Pfad g√ºltig ist
                    try:
                        data_path = data_path.expanduser().resolve()
                        
                        # Pr√ºfe ob Verzeichnis erstellt werden kann
                        data_path.mkdir(parents=True, exist_ok=True)
                        
                        print(f"‚úÖ Datenverzeichnis eingerichtet: {data_path}")
                        break
                    except Exception as e:
                        print(f"‚ùå Ung√ºltiger Pfad: {e}")
                        print("Bitte versuchen Sie es erneut.\n")
            
            # Konfiguration aktualisieren
            self.config['data_directory'] = str(data_path)
            self.config['first_run'] = False
            
            # Konfiguration speichern
            self.save_config()
        else:
            # Gespeichertes Verzeichnis verwenden
            data_path = Path(self.config['data_directory'])
        
        # Erstelle Verzeichnis falls nicht vorhanden
        data_path.mkdir(parents=True, exist_ok=True)
        
        # Kopiere Standard-Daten falls Verzeichnis leer ist
        default_data_path = Path(application_path) / "data"
        if default_data_path.exists() and not any(data_path.iterdir()):
            try:
                for item in default_data_path.iterdir():
                    if item.is_file():
                        shutil.copy2(item, data_path / item.name)
                    elif item.is_dir():
                        shutil.copytree(item, data_path / item.name, dirs_exist_ok=True)
                print(f"‚úÖ Standard-Daten nach {data_path} kopiert")
            except Exception as e:
                print(f"‚ö†Ô∏è  Fehler beim Kopieren der Standard-Daten: {e}")
        
        return data_path

def check_ssl_certificates():
    """Pr√ºft SSL-Zertifikate und gibt Status zur√ºck"""
    # Bestimme Verzeichnis korrekt f√ºr PyInstaller und normale Ausf√ºhrung
    if getattr(sys, 'frozen', False):
        # Wenn als .exe ausgef√ºhrt (PyInstaller)
        script_dir = os.path.dirname(sys.executable)
    else:
        # Normal als Python-Script
        script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # SSL-Dateipfade - os.path.join funktioniert auf allen Plattformen
    ssl_cert_path = os.path.join(script_dir, 'ssl_certificate.crt')
    ssl_key_path = os.path.join(script_dir, 'ssl_private_key.key')
    
    cert_exists = os.path.exists(ssl_cert_path)
    key_exists = os.path.exists(ssl_key_path)
    
    if cert_exists and key_exists:
        print("üîí SSL-Zertifikat und Privatschl√ºssel gefunden")
        print(f"   Zertifikat: {ssl_cert_path}")
        print(f"   Schl√ºssel: {ssl_key_path}")
        return True, ssl_cert_path, ssl_key_path
    else:
        print("‚ö†Ô∏è  SSL-Zertifikatsdateien nicht vollst√§ndig vorhanden:")
        if not cert_exists:
            print(f"   ‚ùå Fehlend: {ssl_cert_path}")
        if not key_exists:
            print(f"   ‚ùå Fehlend: {ssl_key_path}")
        print("   üëâ Stelle sicher, dass beide Dateien im Programmverzeichnis sind")
        return False, None, None

def print_banner():
    """Zeigt Banner"""
    print("üéâ" + "="*60 + "üéâ")
    print("           HOCHZEITSPLANER WEB-ANWENDUNG")
    print("          SSL-Version mit Dual-Domain-Support")
    print("     üåê Lokal: hochzeitsplaner.de")
    print("     üåç Internet: pascalundk√§the-heiraten.de")
    print("üéâ" + "="*60 + "üéâ")
    print()

def find_available_port(start_port=8080):
    """Findet einen verf√ºgbaren Port"""
    ports_to_try = [start_port, 8443, 8081, 8082, 5001, 5002, 3000, 3001]
    
    for port in ports_to_try:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('localhost', port))
                return port
        except OSError:
            continue
    
    return start_port

def get_local_ip():
    """Ermittelt die lokale IP-Adresse"""
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80))
        local_ip = s.getsockname()[0]
        s.close()
        return local_ip
    except Exception:
        return "192.168.1.xxx"

def open_browser_delayed(url, delay=3):
    """√ñffnet Browser nach Verz√∂gerung"""
    def open_browser():
        time.sleep(delay)
        try:
            webbrowser.open(url)
            print(f"üåê Browser ge√∂ffnet: {url}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Browser konnte nicht automatisch ge√∂ffnet werden: {e}")
            print(f"    Bitte √∂ffnen Sie manuell: {url}")
    
    thread = threading.Thread(target=open_browser)
    thread.daemon = True
    thread.start()

def main():
    print_banner()
    
    # Konfiguration laden
    config_manager = SimpleConfig()
    config = config_manager.config
    
    # Datenverzeichnis einrichten
    print("üìÅ Richte Datenverzeichnis ein...")
    data_path = config_manager.setup_data_directory()
    
    # SSL-Zertifikate pr√ºfen
    print("\nüîí Pr√ºfe SSL-Zertifikate...")
    ssl_available, cert_path, key_path = check_ssl_certificates()
    
    # Umgebung vorbereiten
    os.environ['DATA_PATH'] = str(data_path)
    os.environ['FLASK_ENV'] = 'production'
    
    # Port finden
    if ssl_available:
        # F√ºr HTTPS bevorzugt Port 8443 oder 8080
        preferred_port = 8443 if config.get('port', 8080) == 8080 else config.get('port', 8080)
    else:
        preferred_port = config.get('port', 8080)
    
    port = find_available_port(preferred_port)
    if port != preferred_port:
        print(f"‚ö†Ô∏è  Port {preferred_port} belegt, verwende Port {port}")
    
    # Protocol und URL bestimmen
    host = config.get('host', '0.0.0.0')
    use_ssl = ssl_available and config.get('ssl_enabled', True)
    protocol = "https" if use_ssl else "http"
    url = f"{protocol}://localhost:{port}"  # F√ºr Browser-√ñffnung localhost verwenden
    
    # Lokale IP f√ºr Ausgabe
    local_ip = get_local_ip()
    
    print(f"\nüöÄ Starte Server...")
    print(f"üìÇ Datenverzeichnis: {data_path}")
    print(f"üñ•Ô∏è  Server l√§uft auf allen Netzwerk-Interfaces")
    print()
    
    if use_ssl:
        print("üîí SSL aktiviert - Sicherer HTTPS-Modus")
        print("üìç ZUGRIFF-URLS:")
        print(f"   üè† Intern erreichbar: https://localhost:{port}")
        print(f"   üåê Lokal im Netzwerk: https://hochzeitsplaner.de:{port}")
        print(f"   üåç Internet-Domain: https://pascalundk√§the-heiraten.de:{port}")
        print(f"   üì± Direkte IP: https://{local_ip}:{port}")
    else:
        print("‚ö†Ô∏è  HTTP-Modus (unverschl√ºsselt)")
        print("üìç ZUGRIFF-URLS:")
        print(f"   üè† Intern erreichbar: http://localhost:{port}")
        print(f"   üåê Lokal im Netzwerk: http://hochzeitsplaner.de:{port}")
        print(f"   üåç Internet-Domain: http://pascalundk√§the-heiraten.de:{port}")
        print(f"   üì± Direkte IP: http://{local_ip}:{port}")
    
    print()
    print("üí° DOMAIN-KONFIGURATION:")
    print("   üè† F√ºr lokale Domain: python configure_network.py ausf√ºhren")
    print("   üåç F√ºr Internet-Domain: Router + DNS konfigurieren")
    
    # Browser-Thread starten
    if config.get('auto_open_browser', True):
        open_browser_delayed(url)
    
    # Flask App importieren und starten
    try:
        # App importieren
        from app import app
        
        print("\nüìù Logs werden hier angezeigt...")
        print("üõë Zum Beenden: Strg+C oder Fenster schlie√üen")
        print("="*60)
        print()
        
        # SSL-Context vorbereiten
        ssl_context = None
        if use_ssl and cert_path and key_path:
            ssl_context = (cert_path, key_path)
        
        # App starten
        app.run(
            host=host,
            port=port,
            debug=False,
            use_reloader=False,
            threaded=True,
            ssl_context=ssl_context
        )
        
    except KeyboardInterrupt:
        print("\nüõë Anwendung beendet durch Benutzer")
    except Exception as e:
        print(f"‚ùå Fehler beim Starten der Anwendung: {e}")
        print("üîß M√∂gliche L√∂sungen:")
        print("   ‚Ä¢ Pr√ºfen Sie die SSL-Zertifikatsdateien")
        print("   ‚Ä¢ Versuchen Sie einen anderen Port")
        print("   ‚Ä¢ Deaktivieren Sie SSL in der Konfiguration")
        print("\nüìã Dr√ºcken Sie Enter zum Beenden...")
        input()

if __name__ == '__main__':
    main()
